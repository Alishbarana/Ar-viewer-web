<!DOCTYPE html>
<html lang="en">
<head>
    <title>Enhanced WebXR AR Viewer - Educational Models</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            line-height: 24px;
            overscroll-behavior: none;
        }

        /* Camera feed for fallback */
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 1;
            display: none;
        }

        #camera-feed.active {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: calc(100% - 20px);
            left: 10px;
            text-align: center;
            z-index: 100;
            display: block;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #model-selector {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            padding: 12px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #model-selector select {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 16px;
            outline: none;
            min-width: 200px;
        }

        #model-selector select option {
            background: #222;
        }

        /* AR Button - positioned above other controls */
        .ar-button-container {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .webxr-ar-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .webxr-ar-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        /* Enhanced AR Controls */
        .ar-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: row;
            gap: 8px;
            z-index: 100;
            padding: 0 20px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            max-width: 100%;
        }

        .ar-controls::-webkit-scrollbar {
            display: none;
        }

        .ar-controls.active {
            display: flex;
        }

        .ar-button {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 16px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 14px;
            min-width: 70px;
            text-align: center;
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
            touch-action: manipulation;
            user-select: none;
        }

        .ar-button:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .ar-button:active {
            transform: scale(0.95);
        }

        /* Movement Controls */
        .movement-controls {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .movement-controls.active {
            display: flex;
        }

        .movement-button {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(15px);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .movement-button:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* Enhanced Model Info Panel */
        .model-info {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 320px;
            max-height: 60vh;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(30, 30, 30, 0.9));
            padding: 25px;
            border-radius: 15px;
            z-index: 100;
            display: none;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
        }

        .model-info.active {
            display: block;
            animation: slideInLeft 0.3s ease;
        }

        @keyframes slideInLeft {
            from {
                transform: translateY(-50%) translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(-50%) translateX(0);
                opacity: 1;
            }
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-title {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-content {
            font-size: 14px;
            line-height: 1.5;
            opacity: 0.9;
            margin-bottom: 15px;
        }

        .info-highlight {
            background: rgba(102, 126, 234, 0.2);
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
            margin: 10px 0;
        }

        .component-list {
            list-style: none;
            padding: 0;
        }

        .component-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .component-item:hover {
            background: rgba(102, 126, 234, 0.3);
            transform: translateX(5px);
        }

        /* Instructions */
        .instructions {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.8));
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            font-size: 14px;
            max-width: 80%;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        /* Loading and Error States */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(30, 30, 30, 0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.9), rgba(200, 0, 0, 0.8));
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            backdrop-filter: blur(15px);
        }

        .hidden {
            display: none !important;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .progress-text {
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.8;
        }

        /* Fallback AR Crosshair */
        .ar-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            opacity: 0.6;
            display: none;
        }

        .ar-crosshair.active {
            display: block;
        }

        .ar-crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
        }

        /* Debug panel */
        .debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            max-width: 200px;
            z-index: 100;
            display: none;
        }

        .debug-panel.active {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Camera Feed for Fallback -->
    <video id="camera-feed" autoplay muted playsinline></video>

    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing AR experience...</div>
        </div>
    </div>

    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div>WebXR Not Supported</div>
        <div style="margin-top: 10px; font-size: 12px;">Using fallback AR experience</div>
    </div>

    <div id="info">
        <span id="model-title">Enhanced WebXR AR Educational Viewer</span><br/>
        <span id="model-subtitle">Select a model and enter AR to place it in your space</span>
    </div>

    <div id="model-selector">
        <select id="model-select">
            <option value="array">Array Data Structure</option>
            <option value="binary_tree">Binary Tree</option>
            <option value="linked_list">Linked List</option>
            <option value="stack">Stack (LIFO)</option>
            <option value="queue">Queue (FIFO)</option>
            <option value="merge_sort">Merge Sort Algorithm</option>
            <option value="osi_model">OSI Model</option>
            <option value="client_server">Client-Server Architecture</option>
            <option value="firewall">Network Firewall</option>
            <option value="router">Network Router</option>
        </select>
    </div>

    <!-- AR Button positioned above other controls -->
    <div class="ar-button-container" id="ar-button-container">
        <!-- AR Button will be inserted here by Three.js -->
    </div>

    <!-- Enhanced AR Controls -->
    <div class="ar-controls" id="ar-controls">
        <button class="ar-button" onclick="shrinkModel()">
            <span>🔍</span>
            <span>Shrink</span>
        </button>
        <button class="ar-button" onclick="expandModel()">
            <span>🔎</span>
            <span>Expand</span>
        </button>
        <button class="ar-button" onclick="toggleDetails()">
            <span>📋</span>
            <span>Details</span>
        </button>
        <button class="ar-button" onclick="moveLeft()">
            <span>⬅️</span>
            <span>Move Left</span>
        </button>
        <button class="ar-button" onclick="moveRight()">
            <span>➡️</span>
            <span>Move Right</span>
        </button>
    </div>

    <!-- Movement Controls -->
    <div class="movement-controls" id="movement-controls">
        <button class="movement-button" onclick="moveUp()">⬆️</button>
        <button class="movement-button" onclick="moveDown()">⬇️</button>
        <button class="movement-button" onclick="moveForward()">🔼</button>
        <button class="movement-button" onclick="moveBackward()">🔽</button>
    </div>

    <!-- Enhanced Model Info Panel -->
    <div class="model-info" id="model-info">
        <div class="info-section">
            <div class="info-title">
                <span>📋</span>
                <span id="info-title">Model Information</span>
            </div>
            <div class="info-content" id="info-description">
                Select a model to see detailed information about its structure and functionality.
            </div>
        </div>

        <div class="info-section">
            <div class="info-title">
                <span>🔧</span>
                <span>Key Components</span>
            </div>
            <ul class="component-list" id="components-list">
                <li class="component-item">Loading components...</li>
            </ul>
        </div>

        <div class="info-section">
            <div class="info-title">
                <span>⚡</span>
                <span>Performance & Complexity</span>
            </div>
            <div class="info-highlight">
                <div id="info-complexity">Select a model to view complexity analysis</div>
            </div>
        </div>

        <div class="info-section">
            <div class="info-title">
                <span>💡</span>
                <span>Real-world Applications</span>
            </div>
            <div class="info-content" id="info-usage">
                Discover how this concept is used in practice
            </div>
        </div>
    </div>

    <div class="instructions" id="instructions">
        📱 Point your camera at a flat surface and tap to place the model
    </div>

    <!-- AR Crosshair for fallback -->
    <div class="ar-crosshair" id="ar-crosshair"></div>

    <div class="debug-panel" id="debug-panel">
        <div id="debug-content"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer;
        let controller;
        let reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let currentModel = null;
        let modelData = {};
        let placedModels = [];
        let isWebXRSupported = false;
        let fallbackCamera = null;
        let fallbackScene = null;

        // Enhanced model configurations with detailed information
        const MODEL_CONFIGS = {
            array: {
                title: "Array Data Structure",
                subtitle: "Linear collection of elements with indexed access",
                model: "./models/array.glb",
                scale: 0.3,
                description: "Arrays are fundamental linear data structures that store elements in contiguous memory locations. They provide O(1) random access through indexing and are the building blocks for many other data structures.",
                complexity: "Access: O(1), Search: O(n), Insert/Delete: O(n)",
                usage: "Database records, image processing, mathematical computations, buffer implementations, matrix operations",
                components: ["Index-based Access", "Contiguous Memory Layout", "Fixed Size Allocation", "Homogeneous Elements", "Cache-Friendly Design"]
            },
            binary_tree: {
                title: "Binary Tree",
                subtitle: "Hierarchical structure with parent-child relationships",
                model: "./models/binary tree.glb",
                scale: 0.3,
                description: "Binary trees are hierarchical data structures where each node has at most two children. They form the foundation for efficient searching, sorting, and hierarchical data organization.",
                complexity: "Search: O(log n), Insert: O(log n), Delete: O(log n)",
                usage: "File systems, expression parsing, decision trees, database indexing, heap implementations",
                components: ["Root Node", "Parent-Child Relationships", "Left/Right Subtrees", "Leaf Nodes", "Tree Traversal Methods"]
            },
            linked_list: {
                title: "Linked List",
                subtitle: "Sequential nodes connected via pointers",
                model: "./models/linkedlist.glb",
                scale: 0.3,
                description: "Linked lists are dynamic linear data structures where elements (nodes) are connected through pointers. They allow efficient insertion and deletion at any position.",
                complexity: "Access: O(n), Search: O(n), Insert: O(1), Delete: O(1)",
                usage: "Dynamic memory allocation, undo functionality, music playlists, browser history, memory management",
                components: ["Node Structure", "Pointer References", "Head/Tail Pointers", "Dynamic Memory", "Sequential Access"]
            },
            stack: {
                title: "Stack (LIFO)",
                subtitle: "Last In First Out data structure",
                model: "./models/stack.glb",
                scale: 0.3,
                description: "Stacks follow the Last-In-First-Out (LIFO) principle. Elements are added and removed from the same end, making them perfect for managing function calls and temporary data.",
                complexity: "Push: O(1), Pop: O(1), Peek: O(1), Search: O(n)",
                usage: "Function call management, expression evaluation, undo operations, browser back button, recursion handling",
                components: ["Top Pointer", "LIFO Operations", "Push/Pop Methods", "Stack Frame", "Overflow Protection"]
            },
            queue: {
                title: "Queue (FIFO)",
                subtitle: "First In First Out data structure",
                model: "./models/queue.glb",
                scale: 0.3,
                description: "Queues implement the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front, ideal for scheduling and buffering.",
                complexity: "Enqueue: O(1), Dequeue: O(1), Front: O(1), Search: O(n)",
                usage: "Task scheduling, print queues, breadth-first search, CPU scheduling, buffer management",
                components: ["Front/Rear Pointers", "FIFO Operations", "Enqueue/Dequeue", "Circular Implementation", "Buffer Management"]
            },
            merge_sort: {
                title: "Merge Sort Algorithm",
                subtitle: "Divide and conquer sorting technique",
                model: "./models/mergesort .glb",
                scale: 0.3,
                description: "Merge Sort is a divide-and-conquer algorithm that recursively divides the array into halves, sorts them, and merges them back together in sorted order.",
                complexity: "Time: O(n log n), Space: O(n), Stable: Yes",
                usage: "Large dataset sorting, external sorting, stable sorting requirements, parallel processing, database operations",
                components: ["Divide Phase", "Conquer Phase", "Merge Operation", "Recursive Structure", "Stable Sorting"]
            },
            osi_model: {
                title: "OSI Model",
                subtitle: "7-layer network communication framework",
                model: "./models/osi model.glb",
                scale: 0.3,
                description: "The OSI (Open Systems Interconnection) model is a conceptual framework that standardizes network communication into seven distinct layers, each with specific responsibilities.",
                complexity: "Standardized communication, protocol independence, modular design",
                usage: "Network troubleshooting, protocol development, network education, system design, network architecture",
                components: ["Physical Layer", "Data Link Layer", "Network Layer", "Transport Layer", "Session Layer", "Presentation Layer", "Application Layer"]
            },
            client_server: {
                title: "Client-Server Architecture",
                subtitle: "Distributed computing model",
                model: "./models/client-server.glb",
                scale: 0.3,
                description: "Client-Server architecture is a distributed computing model where clients request services from centralized servers, enabling scalable and manageable systems.",
                complexity: "Scalable, centralized management, resource sharing, fault tolerance",
                usage: "Web applications, database systems, email services, file sharing, enterprise applications, cloud computing",
                components: ["Client Applications", "Server Infrastructure", "Request/Response Cycle", "Load Balancing", "Database Integration"]
            },
            firewall: {
                title: "Network Firewall",
                subtitle: "Security barrier for network traffic",
                model: "./models/firewall.glb",
                scale: 0.3,
                description: "Firewalls are network security systems that monitor and control incoming and outgoing traffic based on predetermined security rules and policies.",
                complexity: "Real-time filtering, high throughput, minimal latency impact",
                usage: "Network perimeter security, internal segmentation, malware protection, compliance enforcement, intrusion prevention",
                components: ["Packet Filtering", "Stateful Inspection", "Application Gateway", "Rule Engine", "Logging System"]
            },
            router: {
                title: "Network Router",
                subtitle: "Data packet forwarding device",
                model: "./models/router.glb",
                scale: 0.3,
                description: "Routers are networking devices that forward data packets between computer networks, determining the best path for data transmission using routing algorithms.",
                complexity: "High-speed packet processing, dynamic routing, load balancing",
                usage: "Internet connectivity, network segmentation, traffic management, VPN connections, network optimization",
                components: ["Routing Table", "Packet Forwarding", "Protocol Support", "Interface Management", "Quality of Service"]
            }
        };

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const modelParam = urlParams.get('model');
        const confidenceParam = urlParams.get('confidence');
        const debugParam = urlParams.get('debug');

        console.log('🚀 Enhanced AR Viewer initialized with params:', { 
            model: modelParam, 
            confidence: confidenceParam,
            debug: debugParam 
        });

        // Show debug panel if requested
        if (debugParam === 'true') {
            document.getElementById('debug-panel').classList.add('active');
            updateDebugInfo();
        }

        init();

        async function init() {
            try {
                updateProgress(10, 'Checking WebXR support...');
                
                // Check WebXR support
                if ('xr' in navigator) {
                    isWebXRSupported = await navigator.xr.isSessionSupported('immersive-ar');
                }

                if (isWebXRSupported) {
                    updateProgress(30, 'Initializing WebXR AR...');
                    await initWebXR();
                } else {
                    updateProgress(30, 'Initializing fallback AR...');
                    await initFallbackAR();
                }

                updateProgress(100, 'AR experience ready!');
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 1000);

            } catch (error) {
                console.error('Initialization failed:', error);
                showError('Failed to initialize AR experience');
            }
        }

        async function initWebXR() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Enhanced lighting setup
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Create custom AR Button
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            });
            
            // Style the AR button
            arButton.className = 'webxr-ar-button';
            arButton.textContent = '🚀 Enter AR';
            
            // Position the AR button
            const buttonContainer = document.getElementById('ar-button-container');
            buttonContainer.appendChild(arButton);

            // Controller setup
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Create reticle
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x667eea })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            setupUI();
            setupEventListeners();
        }

        async function initFallbackAR() {
            // Show error briefly then continue with fallback
            const errorDiv = document.getElementById('error');
            errorDiv.classList.remove('hidden');
            setTimeout(() => {
                errorDiv.classList.add('hidden');
            }, 3000);

            // Initialize camera feed
            try {
                const video = document.getElementById('camera-feed');
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                video.classList.add('active');
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve);
                    };
                });
            } catch (error) {
                console.warn('Camera access failed, using black background');
            }

            // Initialize Three.js for fallback
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.zIndex = '2';
            container.style.pointerEvents = 'none';
            document.body.appendChild(container);

            fallbackScene = new THREE.Scene();
            fallbackCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            fallbackCamera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.setAnimationLoop(animateFallback);
            container.appendChild(renderer.domElement);

            // Enhanced lighting for fallback
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            fallbackScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            fallbackScene.add(directionalLight);

            // Show AR crosshair
            document.getElementById('ar-crosshair').classList.add('active');

            // Create fallback AR button
            const arButton = document.createElement('button');
            arButton.className = 'webxr-ar-button';
            arButton.textContent = '📱 Start AR Experience';
            arButton.onclick = startFallbackAR;
            
            const buttonContainer = document.getElementById('ar-button-container');
            buttonContainer.appendChild(arButton);

            setupUI();
            setupEventListeners();
        }

        function startFallbackAR() {
            // Show AR controls for fallback mode
            document.getElementById('ar-controls').classList.add('active');
            document.getElementById('movement-controls').classList.add('active');
            
            // Load initial model
            const modelSelect = document.getElementById('model-select');
            const selectedModel = modelSelect.value;
            loadFallbackModel(selectedModel);
            
            // Hide instructions
            document.getElementById('instructions').style.display = 'none';
        }

        function setupUI() {
            // Setup model selector
            const modelSelect = document.getElementById('model-select');
            modelSelect.addEventListener('change', function() {
                const selectedModel = modelSelect.value;
                modelData = MODEL_CONFIGS[selectedModel];
                updateUI();
                console.log('Model changed to:', selectedModel, modelData);
            });

            // Auto-select model from URL parameter
            if (modelParam && MODEL_CONFIGS[modelParam]) {
                console.log('Auto-selecting model from URL:', modelParam);
                modelSelect.value = modelParam;
                modelData = MODEL_CONFIGS[modelParam];
                updateUI();
                
                // Highlight that model was auto-selected
                document.getElementById('model-title').style.color = '#667eea';
                document.getElementById('model-subtitle').textContent = `Auto-selected: ${modelData.subtitle}`;
            } else {
                // Set default model
                modelData = MODEL_CONFIGS[modelSelect.value];
                updateUI();
            }
        }

        function setupEventListeners() {
            // Setup AR session events
            if (renderer && renderer.xr) {
                renderer.xr.addEventListener('sessionstart', onSessionStart);
                renderer.xr.addEventListener('sessionend', onSessionEnd);
            }

            window.addEventListener('resize', onWindowResize);

            // Send ready signal to React Native
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'ar_ready',
                    selectedModel: modelParam || 'array',
                    webxrSupported: isWebXRSupported
                }));
            }
        }

        function onSessionStart() {
            console.log('AR session started');
            document.getElementById('ar-controls').classList.add('active');
            document.getElementById('movement-controls').classList.add('active');
            
            // Setup hit testing
            const session = renderer.xr.getSession();
            session.requestReferenceSpace('viewer').then(function(referenceSpace) {
                session.requestHitTestSource({ space: referenceSpace }).then(function(source) {
                    hitTestSource = source;
                });
            });

            session.addEventListener('end', function() {
                hitTestSourceRequested = false;
                hitTestSource = null;
            });

            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'webxr_session_started'
                }));
            }
        }

        function onSessionEnd() {
            console.log('AR session ended');
            document.getElementById('ar-controls').classList.remove('active');
            document.getElementById('movement-controls').classList.remove('active');
            document.getElementById('model-info').classList.remove('active');

            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'webxr_session_ended'
                }));
            }
        }

        function onSelect() {
            if (reticle.visible) {
                loadAndPlaceModel();
            }
        }

        function loadAndPlaceModel() {
            const loader = new GLTFLoader();
            
            console.log('Loading model:', modelData.model);
            
            loader.load(
                modelData.model,
                function(gltf) {
                    console.log('✅ Model loaded successfully:', modelData.title);
                    const model = gltf.scene;
                    model.scale.setScalar(modelData.scale);
                    
                    // Position model at reticle location
                    model.position.setFromMatrixPosition(reticle.matrix);
                    model.quaternion.setFromRotationMatrix(reticle.matrix);
                    
                    // Remove previous model if exists
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    currentModel = model;
                    scene.add(model);
                    placedModels.push(model);
                    
                    // Hide instructions
                    document.getElementById('instructions').style.display = 'none';
                    
                    if (window.ReactNativeWebView) {
                        window.ReactNativeWebView.postMessage(JSON.stringify({
                            type: 'model_loaded',
                            modelName: modelData.title
                        }));
                    }
                },
                function(progress) {
                    console.log('Loading progress:', progress);
                },
                function(error) {
                    console.error('❌ Error loading model:', error);
                    createFallbackModel();
                }
            );
        }

        function loadFallbackModel(modelName) {
            const selectedModelData = MODEL_CONFIGS[modelName];
            createFallbackModel(modelName);
        }

        function createFallbackModel(modelName = null) {
            console.log('Creating fallback model for:', modelData.title);
            
            const targetScene = isWebXRSupported ? scene : fallbackScene;
            let model;
            
            const modelKey = modelName || Object.keys(MODEL_CONFIGS).find(key => 
                MODEL_CONFIGS[key] === modelData
            );
            
            switch(modelKey) {
                case 'array':
                    const group = new THREE.Group();
                    for(let i = 0; i < 7; i++) {
                        const boxGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                        const boxMaterial = new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(i * 0.15, 0.7, 0.6)
                        });
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.x = (i - 3) * 0.5;
                        box.castShadow = true;
                        group.add(box);
                    }
                    model = group;
                    break;
                    
                case 'binary_tree':
                    const treeGroup = new THREE.Group();
                    // Root
                    const rootGeometry = new THREE.SphereGeometry(0.2);
                    const rootMaterial = new THREE.MeshLambertMaterial({ color: 0x667eea });
                    const root = new THREE.Mesh(rootGeometry, rootMaterial);
                    root.position.y = 0.5;
                    treeGroup.add(root);
                    
                    // Left and right children
                    const leftChild = new THREE.Mesh(rootGeometry, new THREE.MeshLambertMaterial({ color: 0x764ba2 }));
                    leftChild.position.set(-0.5, 0, 0);
                    const rightChild = new THREE.Mesh(rootGeometry, new THREE.MeshLambertMaterial({ color: 0x764ba2 }));
                    rightChild.position.set(0.5, 0, 0);
                    
                    treeGroup.add(leftChild);
                    treeGroup.add(rightChild);
                    
                    // Connections
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
                    const leftLineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0.5, 0),
                        new THREE.Vector3(-0.5, 0, 0)
                    ]);
                    const rightLineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0.5, 0),
                        new THREE.Vector3(0.5, 0, 0)
                    ]);
                    
                    treeGroup.add(new THREE.Line(leftLineGeometry, lineMaterial));
                    treeGroup.add(new THREE.Line(rightLineGeometry, lineMaterial));
                    
                    model = treeGroup;
                    break;
                    
                case 'osi_model':
                    const osiGroup = new THREE.Group();
                    const layers = ['Physical', 'Data Link', 'Network', 'Transport', 'Session', 'Presentation', 'Application'];
                    for(let i = 0; i < 7; i++) {
                        const layerGeometry = new THREE.BoxGeometry(1, 0.2, 0.8);
                        const layerMaterial = new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(i * 0.14, 0.8, 0.6)
                        });
                        const layer = new THREE.Mesh(layerGeometry, layerMaterial);
                        layer.position.y = i * 0.25 - 0.75;
                        layer.castShadow = true;
                        osiGroup.add(layer);
                    }
                    model = osiGroup;
                    break;
                    
                default:
                    const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    const material = new THREE.MeshLambertMaterial({ color: 0x667eea });
                    model = new THREE.Mesh(geometry, material);
                    break;
            }
            
            if (isWebXRSupported && reticle && reticle.visible) {
                model.position.setFromMatrixPosition(reticle.matrix);
                model.quaternion.setFromRotationMatrix(reticle.matrix);
            } else {
                model.position.set(0, 0, -3);
            }
            
            model.scale.setScalar(modelData.scale);
            
            if (currentModel) {
                targetScene.remove(currentModel);
            }
            
            currentModel = model;
            targetScene.add(model);
            placedModels.push(model);
            
            document.getElementById('instructions').style.display = 'none';
            console.log('✅ Fallback model created');
        }

        function animate() {
            if (renderer.xr.isPresenting) {
                // Handle hit testing for reticle positioning
                if (hitTestSource) {
                    const frame = renderer.xr.getFrame();
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(renderer.xr.getReferenceSpace()).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function animateFallback() {
            if (currentModel) {
                currentModel.rotation.y += 0.01;
            }
            renderer.render(fallbackScene, fallbackCamera);
        }

        function onWindowResize() {
            const targetCamera = isWebXRSupported ? camera : fallbackCamera;
            targetCamera.aspect = window.innerWidth / window.innerHeight;
            targetCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateUI() {
            document.getElementById('model-title').textContent = modelData.title;
            document.getElementById('model-subtitle').textContent = modelData.subtitle;
            
            // Update enhanced info panel
            document.getElementById('info-title').textContent = modelData.title;
            document.getElementById('info-description').textContent = modelData.description;
            document.getElementById('info-complexity').textContent = modelData.complexity;
            document.getElementById('info-usage').textContent = modelData.usage;
            
            // Update components list
            const componentsList = document.getElementById('components-list');
            componentsList.innerHTML = '';
            modelData.components.forEach((component, index) => {
                const li = document.createElement('li');
                li.className = 'component-item';
                li.textContent = component;
                li.onclick = () => highlightComponent(index);
                componentsList.appendChild(li);
            });
            
            updateDebugInfo();
        }

        function highlightComponent(index) {
            console.log('Highlighting component:', index);
            // Add visual highlight effect to model component
            if (currentModel && currentModel.children[index]) {
                const component = currentModel.children[index];
                const originalMaterial = component.material;
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x667eea,
                    transparent: true,
                    opacity: 0.7
                });
                
                component.material = highlightMaterial;
                
                setTimeout(() => {
                    component.material = originalMaterial;
                }, 2000);
            }
        }

        function updateDebugInfo() {
            if (debugParam === 'true') {
                const debugContent = document.getElementById('debug-content');
                debugContent.innerHTML = `
                    <strong>Debug Info:</strong><br>
                    Model Param: ${modelParam || 'none'}<br>
                    Current Model: ${modelData.title}<br>
                    Model File: ${modelData.model}<br>
                    WebXR Support: ${isWebXRSupported ? '✅' : '❌'}<br>
                    Fallback Mode: ${!isWebXRSupported ? '✅' : '❌'}<br>
                    HTTPS: ${location.protocol === 'https:' ? '✅' : '❌'}
                `;
            }
        }

        function updateProgress(percent, message = '') {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            if (progressFill) {
                progressFill.style.width = percent + '%';
            }
            
            if (progressText && message) {
                progressText.textContent = message;
            }
        }

        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            const errorDiv = document.getElementById('error');
            if (errorDiv) {
                const errorText = errorDiv.querySelector('div');
                if (errorText) {
                    errorText.textContent = message;
                }
                errorDiv.classList.remove('hidden');
            }
        }

        // Enhanced AR Control Functions
        window.shrinkModel = function() {
            if (currentModel) {
                currentModel.scale.multiplyScalar(0.8);
                console.log('Model shrunk');
            }
        };

        window.expandModel = function() {
            if (currentModel) {
                currentModel.scale.multiplyScalar(1.25);
                console.log('Model expanded');
            }
        };

        window.toggleDetails = function() {
            const infoPanel = document.getElementById('model-info');
            infoPanel.classList.toggle('active');
        };

        window.moveLeft = function() {
            if (currentModel) {
                currentModel.position.x -= 0.1;
                console.log('Model moved left');
            }
        };

        window.moveRight = function() {
            if (currentModel) {
                currentModel.position.x += 0.1;
                console.log('Model moved right');
            }
        };

        window.moveUp = function() {
            if (currentModel) {
                currentModel.position.y += 0.1;
                console.log('Model moved up');
            }
        };

        window.moveDown = function() {
            if (currentModel) {
                currentModel.position.y -= 0.1;
                console.log('Model moved down');
            }
        };

        window.moveForward = function() {
            if (currentModel) {
                currentModel.position.z -= 0.1;
                console.log('Model moved forward');
            }
        };

        window.moveBackward = function() {
            if (currentModel) {
                currentModel.position.z += 0.1;
                console.log('Model moved backward');
            }
        };

        // Handle messages from React Native
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                switch(data.type) {
                    case 'change_model':
                        changeModel(data.modelName);
                        break;
                    case 'reset_view':
                        resetView();
                        break;
                }
            } catch (error) {
                console.error('Error handling message:', error);
            }
        });

        async function changeModel(newModelName) {
            try {
                const targetScene = isWebXRSupported ? scene : fallbackScene;
                if (currentModel) {
                    targetScene.remove(currentModel);
                }
                
                modelData = MODEL_CONFIGS[newModelName] || MODEL_CONFIGS.array;
                updateUI();
                
                if (isWebXRSupported) {
                    await loadAndPlaceModel();
                } else {
                    loadFallbackModel(newModelName);
                }
            } catch (error) {
                console.error('Change model error:', error);
            }
        }

        function resetView() {
            if (currentModel) {
                currentModel.rotation.set(0, 0, 0);
                currentModel.scale.setScalar(modelData.scale);
                if (!isWebXRSupported) {
                    currentModel.position.set(0, 0, -3);
                }
            }
        }

        // Error handling
        window.addEventListener('error', function(event) {
            console.error('AR Error:', event.error);
            if (!event.error.message.includes('camera')) {
                showError('An error occurred in AR view');
            }
        });

        // Handle page visibility change
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // Pause any animations or processes
                console.log('Page hidden, pausing AR');
            } else {
                console.log('Page visible, resuming AR');
            }
        });

    </script>
</body>
</html>