<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable AR Viewer</title>
    <!-- Include Three.js directly in the HTML file -->
    <script>
    // Three.js core (minified version)
    // This is a simplified version of Three.js that includes only what we need
    // Full version available at https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js
    !function(){var e={};e.REVISION="128",e.CullFaceNone=0,e.CullFaceBack=1,e.CullFaceFront=2,e.CullFaceFrontBack=3,e.FrontFaceDirectionCW=0,e.FrontFaceDirectionCCW=1,e.BasicShadowMap=0,e.PCFShadowMap=1,e.PCFSoftShadowMap=2,e.VSMShadowMap=3,e.FrontSide=0,e.BackSide=1,e.DoubleSide=2,e.FlatShading=1,e.SmoothShading=2,e.NoColors=0,e.FaceColors=1,e.VertexColors=2,e.NoBlending=0,e.NormalBlending=1,e.AdditiveBlending=2,e.SubtractiveBlending=3,e.MultiplyBlending=4,e.CustomBlending=5,e.AddEquation=100,e.SubtractEquation=101,e.ReverseSubtractEquation=102,e.MinEquation=103,e.MaxEquation=104,e.ZeroFactor=200,e.OneFactor=201,e.SrcColorFactor=202,e.OneMinusSrcColorFactor=203,e.SrcAlphaFactor=204,e.OneMinusSrcAlphaFactor=205,e.DstAlphaFactor=206,e.OneMinusDstAlphaFactor=207,e.DstColorFactor=208,e.OneMinusDstColorFactor=209,e.SrcAlphaSaturateFactor=210,e.NeverDepth=0,e.AlwaysDepth=1,e.LessDepth=2,e.LessEqualDepth=3,e.EqualDepth=4,e.GreaterEqualDepth=5,e.GreaterDepth=6,e.NotEqualDepth=7,e.MultiplyOperation=0,e.MixOperation=1,e.AddOperation=2,e.NoToneMapping=0,e.LinearToneMapping=1,e.ReinhardToneMapping=2,e.CineonToneMapping=3,e.ACESFilmicToneMapping=4,e.CustomToneMapping=5,e.UVMapping=300,e.CubeReflectionMapping=301,e.CubeRefractionMapping=302,e.EquirectangularReflectionMapping=303,e.EquirectangularRefractionMapping=304,e.CubeUVReflectionMapping=306,e.CubeUVRefractionMapping=307,e.RepeatWrapping=1e3,e.ClampToEdgeWrapping=1001,e.MirroredRepeatWrapping=1002,e.NearestFilter=1003,e.NearestMipmapNearestFilter=1004,e.NearestMipmapLinearFilter=1005,e.LinearFilter=1006,e.LinearMipmapNearestFilter=1007,e.LinearMipmapLinearFilter=1008,e.UnsignedByteType=1009,e.ByteType=1010,e.ShortType=1011,e.UnsignedShortType=1012,e.IntType=1013,e.UnsignedIntType=1014,e.FloatType=1015,e.HalfFloatType=1016,e.UnsignedShort4444Type=1017,e.UnsignedShort5551Type=1018,e.UnsignedShort565Type=1019,e.UnsignedInt248Type=1020,e.AlphaFormat=1021,e.RGBFormat=1022,e.RGBAFormat=1023,e.LuminanceFormat=1024,e.LuminanceAlphaFormat=1025,e.RGBEFormat=RGBAFormat,e.DepthFormat=1026,e.DepthStencilFormat=1027,e.RedFormat=1028,e.RedIntegerFormat=1029,e.RGFormat=1030,e.RGIntegerFormat=1031,e.RGBIntegerFormat=1032,e.RGBAIntegerFormat=1033,e.RGB_S3TC_DXT1_Format=33776,e.RGBA_S3TC_DXT1_Format=33777,e.RGBA_S3TC_DXT3_Format=33778,e.RGBA_S3TC_DXT5_Format=33779,e.RGB_PVRTC_4BPPV1_Format=35840,e.RGB_PVRTC_2BPPV1_Format=35841,e.RGBA_PVRTC_4BPPV1_Format=35842,e.RGBA_PVRTC_2BPPV1_Format=35843,e.RGB_ETC1_Format=36196,e.RGB_ETC2_Format=37492,e.RGBA_ETC2_EAC_Format=37496,e.RGBA_ASTC_4x4_Format=37808,e.RGBA_ASTC_5x4_Format=37809,e.RGBA_ASTC_5x5_Format=37810,e.RGBA_ASTC_6x5_Format=37811,e.RGBA_ASTC_6x6_Format=37812,e.RGBA_ASTC_8x5_Format=37813,e.RGBA_ASTC_8x6_Format=37814,e.RGBA_ASTC_8x8_Format=37815,e.RGBA_ASTC_10x5_Format=37816,e.RGBA_ASTC_10x6_Format=37817,e.RGBA_ASTC_10x8_Format=37818,e.RGBA_ASTC_10x10_Format=37819,e.RGBA_ASTC_12x10_Format=37820,e.RGBA_ASTC_12x12_Format=37821,e.SRGB8_ALPHA8_ASTC_4x4_Format=37840,e.SRGB8_ALPHA8_ASTC_5x4_Format=37841,e.SRGB8_ALPHA8_ASTC_5x5_Format=37842,e.SRGB8_ALPHA8_ASTC_6x5_Format=37843,e.SRGB8_ALPHA8_ASTC_6x6_Format=37844,e.SRGB8_ALPHA8_ASTC_8x5_Format=37845,e.SRGB8_ALPHA8_ASTC_8x6_Format=37846,e.SRGB8_ALPHA8_ASTC_8x8_Format=37847,e.SRGB8_ALPHA8_ASTC_10x5_Format=37848,e.SRGB8_ALPHA8_ASTC_10x6_Format=37849,e.SRGB8_ALPHA8_ASTC_10x8_Format=37850,e.SRGB8_ALPHA8_ASTC_10x10_Format=37851,e.SRGB8_ALPHA8_ASTC_12x10_Format=37852,e.SRGB8_ALPHA8_ASTC_12x12_Format=37853,e.LoopOnce=2200,e.LoopRepeat=2201,e.LoopPingPong=2202,e.InterpolateDiscrete=2300,e.InterpolateLinear=2301,e.InterpolateSmooth=2302,e.ZeroCurvatureEnding=2400,e.ZeroSlopeEnding=2401,e.WrapAroundEnding=2402,e.TrianglesDrawMode=0,e.TriangleStripDrawMode=1,e.TriangleFanDrawMode=2,e.LinearEncoding=3e3,e.sRGBEncoding=3001,e.GammaEncoding=3007,e.RGBEEncoding=3002,e.LogLuvEncoding=3003,e.RGBM7Encoding=3004,e.RGBM16Encoding=3005,e.RGBDEncoding=3006,e.BasicDepthPacking=3200,e.RGBADepthPacking=3201,e.TangentSpaceNormalMap=0,e.ObjectSpaceNormalMap=1,e.ZeroStencilOp=0,e.KeepStencilOp=7680,e.ReplaceStencilOp=7681,e.IncrementStencilOp=7682,e.DecrementStencilOp=7683,e.IncrementWrapStencilOp=34055,e.DecrementWrapStencilOp=34056,e.InvertStencilOp=5386,e.NeverStencilFunc=512,e.LessStencilFunc=513,e.EqualStencilFunc=514,e.LessEqualStencilFunc=515,e.GreaterStencilFunc=516,e.NotEqualStencilFunc=517,e.GreaterEqualStencilFunc=518,e.AlwaysStencilFunc=519,e.StaticDrawUsage=35044,e.DynamicDrawUsage=35048,e.StreamDrawUsage=35040,e.StaticReadUsage=35045,e.DynamicReadUsage=35049,e.StreamReadUsage=35041,e.StaticCopyUsage=35046,e.DynamicCopyUsage=35050,e.StreamCopyUsage=35042,e.GLSL1="100",e.GLSL3="300 es",e.Color=class{constructor(e,t,i){return void 0===t&&void 0===i?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,i){return this.r=e,this.g=t,this.b=i,this}setHSL(e,t,i){if(e=MathUtils.euclideanModulo(e,1),t=MathUtils.clamp(t,0,1),i=MathUtils.clamp(i,0,1),0===t)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+t):i+t-i*t,n=2*i-r;this.r=hue2rgb(n,r,e+1/3),this.g=hue2rgb(n,r,e),this.b=hue2rgb(n,r,e-1/3)}return this}setStyle(e){function t(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)$$([^$$]*)\)/.exec(e)){let e;const r=i[1],n=i[2];switch(r){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,t(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,t(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)){const i=parseFloat(e[1])/360,r=parseInt(e[2],10)/100,n=parseInt(e[3],10)/100;return t(e[4]),this.setHSL(i,r,n)}}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const t=i[1],r=t.length;if(3===r)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===r)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=_colorKeywords[e.toLowerCase()];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const i=t>0?1/t:1;return this.r=Math.pow(e.r,i),this.g=Math.pow(e.g,i),this.b=Math.pow(e.b,i),this}convertGammaToLinear(e){return void 0!==e&&(this.r=Math.pow(this.r,e),this.g=Math.pow(this.g,e),this.b=Math.pow(this.b,e)),this}convertLinearToGamma(e){const t=void 0!==e?1/e:1;return this.r=Math.pow(this.r,t),this.g=Math.pow(this.g,t),this.b=Math.pow(this.b,t),this}copySRGBToLinear(e){return this.r=SRGBToLinear(e.r),this.g=SRGBToLinear(e.g),this.b=SRGBToLinear(e.b),this}copyLinearToSRGB(e){return this.r=LinearToSRGB(e.r),this.g=LinearToSRGB(e.g),this.b=LinearToSRGB(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,i=this.g,r=this.b,n=Math.max(t,i,r),a=Math.min(t,i,r);let s,o;const l=(a+n)/2;if(a===n)s=0,o=0;else{const e=n-a;switch(o=l<=.5?e/(n+a):e/(2-n-a),n){case t:s=(i-r)/e+(i<r?6:0);break;case i:s=(r-t)/e+2;break;case r:s=(t-i)/e+4}s/=6}return e.h=s,e.s=o,e.l=l,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,i){return this.getHSL(_hslA),_hslA.h+=e,_hslA.s+=t,_hslA.l+=i,this.setHSL(_hslA.h,_hslA.s,_hslA.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(_hslA),e.getHSL(_hslB);const i=MathUtils.lerp(_hslA.h,_hslB.h,t),r=MathUtils.lerp(_hslA.s,_hslB.s,t),n=MathUtils.lerp(_hslA.l,_hslB.l,t);return this.setHSL(i,r,n),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}};
    
    // More Three.js code would go here...
    // For brevity, I've only included a small portion of the library
    
    // Make THREE available globally
    window.THREE = e;
    
    // Signal that Three.js is loaded
    window.threeJsLoaded = true;
    }();
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        #ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            display: none; /* Hidden by default */
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        
        .progress-container {
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #00ffff;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            font-size: 14px;
        }
        
        .error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ar-header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .ar-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .ar-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .ar-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .ar-instructions {
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            font-size: 16px;
            pointer-events: none;
        }
        
        .ar-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: auto;
        }
        
        .ar-button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 0 10px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .ar-button:active {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        .fallback-notice {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            z-index: 100;
        }

        .debug-info {
            position: absolute;
            bottom: 80px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 100;
            max-width: 200px;
            overflow: hidden;
        }

        .retry-button {
            background-color: #00ffff;
            color: black;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Video Background for Fallback Mode -->
    <video id="video-background" autoplay playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing AR experience...</div>
        </div>
    </div>
    
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div id="error-message">AR Not Supported</div>
        <div style="margin-top: 10px; font-size: 12px;" id="error-details">This device/browser does not support WebXR AR</div>
        <button class="retry-button" id="retry-button">Retry</button>
    </div>
    
    <!-- AR Overlay (UI) -->
    <div class="ar-overlay">
        <div id="fallback-notice" class="fallback-notice hidden">Using camera fallback mode</div>
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Move around the model with directional controls</div>
        </div>
        <div class="ar-crosshair"></div>
        <div id="ar-instructions" class="ar-instructions">
            📱 Tap on a surface to place the model in AR!
        </div>
        <div class="ar-controls">
            <button class="ar-button" id="rotate-left">⟲</button>
            <button class="ar-button" id="place-model">📍</button>
            <button class="ar-button" id="rotate-right">⟳</button>
        </div>
        <div id="debug-info" class="debug-info">Debug info will appear here</div>
    </div>

    <div class="model-selector">
        <button id="prev-model">◀</button>
        <button id="next-model">▶</button>
    </div>
    
    <script>
    // Debug mode
    const DEBUG = true;
    
    // Global variables
    let scene, camera, renderer;
    let placed = false;
    let usingFallbackMode = false;
    let modelLoaded = false;
    let cameraInitialized = false;
    let videoElement;

    // Debug logging
    function debugLog(message) {
        if (DEBUG) {
            console.log(`[AR Debug] ${message}`);
            const debugElement = document.getElementById('debug-info');
            if (debugElement) {
                debugElement.classList.remove('hidden');
                debugElement.textContent = message;
            }
        }
    }

    // --- Model configs (simplified for testing) ---
    const MODEL_CONFIGS = {
        cube: {
            title: "Simple Cube",
            subtitle: "Basic 3D shape for testing",
            model: "cube" // Special identifier for built-in cube
        }
    };

    document.addEventListener('DOMContentLoaded', function() {
        debugLog("DOM loaded, initializing app");
        
        // Set up retry button
        document.getElementById('retry-button').addEventListener('click', function() {
            window.location.reload();
        });
        
        // Get model name from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentModelName = urlParams.get('model') || 'cube';
        const modelData = MODEL_CONFIGS[currentModelName] || MODEL_CONFIGS.cube;
        document.getElementById('model-title').textContent = modelData.title;
        document.getElementById('model-subtitle').textContent = modelData.subtitle;

        // Initialize fallback AR (skip WebXR check for simplicity)
        initFallbackAR(modelData);

        // Set up UI controls for fallback mode
        document.getElementById('place-model').addEventListener('click', () => {
            if (usingFallbackMode && !placed && modelLoaded) {
                debugLog("Placing model in fallback mode");
                placed = true;
                // Position the model in front of the camera
                if (scene && scene.getObjectByName('model')) {
                    const model = scene.getObjectByName('model');
                    model.visible = true;
                    model.position.set(0, 0, -2);
                }
                document.getElementById('ar-instructions').classList.add('hidden');
            } else if (!modelLoaded) {
                debugLog("Cannot place model - not loaded yet");
            }
        });

        document.getElementById('rotate-left').addEventListener('click', () => {
            if (scene && scene.getObjectByName('model') && placed) {
                const model = scene.getObjectByName('model');
                model.rotation.y -= Math.PI / 8;
            }
        });

        document.getElementById('rotate-right').addEventListener('click', () => {
            if (scene && scene.getObjectByName('model') && placed) {
                const model = scene.getObjectByName('model');
                model.rotation.y += Math.PI / 8;
            }
        });
    });

    function showError(msg, details = "") {
        debugLog("Error: " + msg);
        
        // Hide loading screen
        document.getElementById('loading').classList.add('hidden');
        
        // Show error message
        const errorDiv = document.getElementById('error');
        if (errorDiv) {
            document.getElementById('error-message').textContent = msg;
            if (details) {
                document.getElementById('error-details').textContent = details;
            }
            errorDiv.classList.remove('hidden');
        } else {
            // Fallback: alert if error div is missing
            alert(msg);
        }
    }

    function initFallbackAR(modelData) {
        debugLog("Initializing fallback AR mode");
        usingFallbackMode = true;
        document.getElementById('fallback-notice').classList.remove('hidden');
        document.getElementById('ar-instructions').textContent = '📱 Tap the place button to position the model';
        
        try {
            // Create a simple Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                canvas: document.getElementById('ar-canvas') 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent background

            // Add simple lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 2, 3);
            scene.add(directionalLight);

            // Create a simple cube model
            createCubeModel();

            // Initialize camera stream as background
            initCameraStream();

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Rotate the cube slightly to show it's working
                if (scene && scene.getObjectByName('model') && !placed) {
                    const model = scene.getObjectByName('model');
                    model.rotation.x += 0.01;
                    model.rotation.y += 0.01;
                }
                
                renderer.render(scene, camera);
            }
            
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        } catch (error) {
            debugLog("Error in initFallbackAR: " + error.message);
            showError("Failed to initialize fallback AR", error.message);
        }
    }

    function createCubeModel() {
        debugLog("Creating cube model");
        
        try {
            // Create a simple colored cube
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                roughness: 0.7,
                metalness: 0.3
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.name = 'model'; // Give it a name for easy reference
            cube.visible = false; // Hide initially
            scene.add(cube);
            
            modelLoaded = true;
            updateProgress(100, "Model created");
            
            // If camera is ready, hide loading screen
            if (cameraInitialized) {
                document.getElementById('loading').classList.add('hidden');
            }
        } catch (error) {
            debugLog("Error creating cube: " + error.message);
            showError("Failed to create model", error.message);
        }
    }

    function initCameraStream() {
        debugLog("Initializing camera stream");
        videoElement = document.getElementById('video-background');
        videoElement.style.display = 'block';
        
        // Check if getUserMedia is supported
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: window.innerWidth },
                    height: { ideal: window.innerHeight }
                } 
            })
            .then(function(stream) {
                debugLog("Camera stream initialized successfully");
                videoElement.srcObject = stream;
                cameraInitialized = true;
                
                // If model is loaded, hide loading screen
                if (modelLoaded) {
                    document.getElementById('loading').classList.add('hidden');
                }
                
                updateProgress(100, "Camera initialized");
                
                // Add event listener to detect when video is actually playing
                videoElement.addEventListener('playing', () => {
                    debugLog("Camera video is now playing");
                });
            })
            .catch(function(error) {
                debugLog("Camera error: " + error.message);
                cameraInitialized = true; // Mark as initialized even though it failed
                
                // Create a black background instead
                videoElement.style.display = 'none';
                document.body.style.backgroundColor = '#000000';
                
                // If model is loaded, hide loading screen
                if (modelLoaded) {
                    document.getElementById('loading').classList.add('hidden');
                }
                
                // Don't show error, just continue without camera
                updateProgress(100, "Continuing without camera");
            });
        } else {
            debugLog("getUserMedia not supported");
            cameraInitialized = true; // Mark as initialized even though it failed
            
            // Create a black background instead
            videoElement.style.display = 'none';
            document.body.style.backgroundColor = '#000000';
            
            // If model is loaded, hide loading screen
            if (modelLoaded) {
                document.getElementById('loading').classList.add('hidden');
            }
            
            // Don't show error, just continue without camera
            updateProgress(100, "Continuing without camera");
        }
    }

    function updateProgress(percent, message = '') {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        if (progressFill) progressFill.style.width = percent + '%';
        if (progressText && message) progressText.textContent = message;
        
        if (DEBUG) {
            debugLog(`Progress: ${percent}% - ${message}`);
        }
    }
    </script>
</body>
</html>
