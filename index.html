<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable AR Viewer</title>
    <!-- Three.js & WebXR - Use full paths and add integrity checks -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <!-- Import modules properly for better compatibility -->
    <script type="module">
        // Import modules directly to avoid "not defined" errors
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/ARButton.js';
        
        // Make them available globally
        window.THREE = THREE;
        window.GLTFLoader = GLTFLoader;
        window.ARButton = ARButton;
        
        // Signal that modules are loaded
        window.modulesLoaded = true;
        
        // Dispatch event when modules are ready
        window.dispatchEvent(new Event('threejsModulesLoaded'));
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        #ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            display: none; /* Hidden by default */
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        
        .progress-container {
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #00ffff;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            font-size: 14px;
        }
        
        .error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ar-header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .ar-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .ar-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .ar-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .ar-instructions {
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            font-size: 16px;
            pointer-events: none;
        }
        
        .ar-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: auto;
        }
        
        .ar-button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 0 10px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .ar-button:active {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        .fallback-notice {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            z-index: 100;
        }

        .debug-info {
            position: absolute;
            bottom: 80px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 100;
            max-width: 200px;
            overflow: hidden;
        }

        .retry-button {
            background-color: #00ffff;
            color: black;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Video Background for Fallback Mode -->
    <video id="video-background" autoplay playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing AR experience...</div>
        </div>
    </div>
    
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div id="error-message">AR Not Supported</div>
        <div style="margin-top: 10px; font-size: 12px;" id="error-details">This device/browser does not support WebXR AR</div>
        <button class="retry-button" id="retry-button">Retry</button>
    </div>
    
    <!-- AR Overlay (UI) -->
    <div class="ar-overlay">
        <div id="fallback-notice" class="fallback-notice hidden">Using camera fallback mode</div>
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Move around the model with directional controls</div>
        </div>
        <div class="ar-crosshair"></div>
        <div id="ar-instructions" class="ar-instructions">
            üì± Tap on a surface to place the model in AR!
        </div>
        <div class="ar-controls">
            <button class="ar-button" id="rotate-left">‚ü≤</button>
            <button class="ar-button" id="place-model">üìç</button>
            <button class="ar-button" id="rotate-right">‚ü≥</button>
        </div>
        <div id="debug-info" class="debug-info">Debug info will appear here</div>
    </div>

    <div class="model-selector">
        <button id="prev-model">‚óÄ</button>
        <button id="next-model">‚ñ∂</button>
    </div>
    
    <script>
    // Debug mode
    const DEBUG = true;
    
    // Global variables
    let scene, camera, renderer, controller, reticle, model, currentModelName;
    let placed = false;
    let usingFallbackMode = false;
    let gyroAvailable = false;
    let deviceOrientationControls = null;
    let modelRotationY = 0;
    let videoElement;
    let modelLoaded = false;
    let cameraInitialized = false;
    let initializationTimeout;
    let loadingTimeoutDuration = 15000; // 15 seconds timeout

    // Debug logging
    function debugLog(message) {
        if (DEBUG) {
            console.log(`[AR Debug] ${message}`);
            const debugElement = document.getElementById('debug-info');
            if (debugElement) {
                debugElement.classList.remove('hidden');
                debugElement.textContent = message;
            }
        }
    }

    // --- Model configs (relative paths for GitHub Pages) ---
    const MODEL_CONFIGS = {
        array: {
            title: "Array Data Structure",
            subtitle: "Linear collection of elements with indexed access",
            model: "models/array.glb"
        },
        binary_tree: {
            title: "Binary Tree",
            subtitle: "Hierarchical structure with parent-child relationships",
            model: "models/binary_tree.glb"
        },
        linked_list: {
            title: "Linked List",
            subtitle: "Sequential nodes connected via pointers",
            model: "models/linked_list.glb"
        },
        stack: {
            title: "Stack (LIFO)",
            subtitle: "Last In First Out data structure",
            model: "models/stack.glb"
        },
        queue: {
            title: "Queue (FIFO)",
            subtitle: "First In First Out data structure",
            model: "models/queue.glb"
        },
        merge_sort: {
            title: "Merge Sort Algorithm",
            subtitle: "Divide and conquer sorting technique",
            model: "models/merge_sort.glb"
        },
        osi_model: {
            title: "OSI Model",
            subtitle: "7-layer network communication framework",
            model: "models/osi_model.glb"
        },
        client_server: {
            title: "Client-Server Architecture",
            subtitle: "Distributed computing model",
            model: "models/client_server.glb"
        },
        firewall: {
            title: "Network Firewall",
            subtitle: "Security barrier for network traffic",
            model: "models/firewall.glb"
        },
        router: {
            title: "Network Router",
            subtitle: "Data packet forwarding device",
            model: "models/router.glb"
        }
    };

    // Wait for modules to load before initializing
    function initApp() {
        debugLog("DOM loaded, initializing app");
        
        // Set up retry button
        document.getElementById('retry-button').addEventListener('click', function() {
            window.location.reload();
        });
        
        // Get model name from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentModelName = urlParams.get('model') || 'array';
        const modelData = MODEL_CONFIGS[currentModelName] || MODEL_CONFIGS.array;
        document.getElementById('model-title').textContent = modelData.title;
        document.getElementById('model-subtitle').textContent = modelData.subtitle;

        // Set initialization timeout
        initializationTimeout = setTimeout(() => {
            debugLog("Initialization timeout reached");
            if (!modelLoaded || (usingFallbackMode && !cameraInitialized)) {
                showError("AR initialization timed out. Please check your internet connection and try again.");
            }
        }, loadingTimeoutDuration);

        // Check WebXR support with robust error handling
        try {
            debugLog("Checking WebXR support");
            if (navigator.xr && typeof navigator.xr.isSessionSupported === 'function') {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        debugLog("WebXR AR is supported");
                        initWebXR(modelData);
                    } else {
                        debugLog("WebXR AR not supported, trying fallback mode");
                        initFallbackAR(modelData);
                    }
                }).catch((err) => {
                    debugLog("Error checking WebXR support: " + err.message);
                    initFallbackAR(modelData);
                });
            } else {
                debugLog("WebXR not available, trying fallback mode");
                initFallbackAR(modelData);
            }
        } catch (e) {
            debugLog("Exception during AR support check: " + e.message);
            initFallbackAR(modelData);
        }

        // Set up UI controls for fallback mode
        document.getElementById('place-model').addEventListener('click', () => {
            if (usingFallbackMode && !placed && model && modelLoaded) {
                debugLog("Placing model in fallback mode");
                placed = true;
                model.visible = true;
                // Position the model in front of the camera
                model.position.set(0, 0, -2);
                document.getElementById('ar-instructions').classList.add('hidden');
            } else if (!modelLoaded) {
                debugLog("Cannot place model - not loaded yet");
            }
        });

        document.getElementById('rotate-left').addEventListener('click', () => {
            if (model && placed) {
                modelRotationY -= Math.PI / 8;
                model.rotation.y = modelRotationY;
            }
        });

        document.getElementById('rotate-right').addEventListener('click', () => {
            if (model && placed) {
                modelRotationY += Math.PI / 8;
                model.rotation.y = modelRotationY;
            }
        });

        // Set up model selector
        const modelKeys = Object.keys(MODEL_CONFIGS);
        let currentModelIndex = modelKeys.indexOf(currentModelName);

        document.getElementById('prev-model').addEventListener('click', () => {
            currentModelIndex = (currentModelIndex - 1 + modelKeys.length) % modelKeys.length;
            loadNewModel(modelKeys[currentModelIndex]);
        });

        document.getElementById('next-model').addEventListener('click', () => {
            currentModelIndex = (currentModelIndex + 1) % modelKeys.length;
            loadNewModel(modelKeys[currentModelIndex]);
        });
    }

    function showError(msg, details = "") {
        debugLog("Error: " + msg);
        clearTimeout(initializationTimeout);
        
        // Hide loading screen
        document.getElementById('loading').classList.add('hidden');
        
        // Show error message
        const errorDiv = document.getElementById('error');
        if (errorDiv) {
            document.getElementById('error-message').textContent = msg;
            if (details) {
                document.getElementById('error-details').textContent = details;
            }
            errorDiv.classList.remove('hidden');
        } else {
            // Fallback: alert if error div is missing
            alert(msg);
        }
    }

    function initWebXR(modelData) {
        debugLog("Initializing WebXR");
        
        try {
            // Check if THREE is available
            if (!window.THREE) {
                throw new Error("THREE.js not loaded");
            }
            
            // Setup Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: document.getElementById('ar-canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;

            // Lighting
            scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(1, 2, 3);
            scene.add(light);

            // Reticle for placement
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Check if ARButton is available
            if (!window.ARButton) {
                throw new Error("ARButton not loaded");
            }

            // ARButton
            try {
                document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
            } catch (e) {
                debugLog("Error creating AR button: " + e.message);
                throw new Error("Failed to create AR button: " + e.message);
            }

            // Controller for hit test
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Load model (but don't add to scene yet)
            loadModel(modelData.model);

            // Animation loop
            renderer.setAnimationLoop(render);

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Hit test source
            let hitTestSource = null;
            let hitTestSourceRequested = false;

            function render(timestamp, frame) {
                if (frame) {
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const session = renderer.xr.getSession();

                    if (!hitTestSourceRequested) {
                        session.requestReferenceSpace('viewer').then((refSpace) => {
                            session.requestHitTestSource({ space: refSpace }).then((source) => {
                                hitTestSource = source;
                            });
                        });
                        session.addEventListener('end', () => {
                            hitTestSourceRequested = false;
                            hitTestSource = null;
                        });
                        hitTestSourceRequested = true;
                    }

                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0 && !placed) {
                            const hit = hitTestResults[0];
                            const pose = hit.getPose(referenceSpace);
                            reticle.visible = true;
                            reticle.matrix.fromArray(pose.transform.matrix);
                        } else {
                            reticle.visible = false;
                        }
                    }
                }

                renderer.render(scene, camera);
            }

            function onSelect() {
                if (reticle.visible && model && !placed) {
                    model.position.setFromMatrixPosition(reticle.matrix);
                    model.visible = true;
                    placed = true;
                    reticle.visible = false;
                    document.getElementById('ar-instructions').classList.add('hidden');
                }
            }
        } catch (error) {
            debugLog("Error in initWebXR: " + error.message);
            showError("Failed to initialize AR", error.message);
            // Try fallback mode instead
            initFallbackAR(modelData);
        }
    }

    function initFallbackAR(modelData) {
        debugLog("Initializing fallback AR mode");
        usingFallbackMode = true;
        document.getElementById('fallback-notice').classList.remove('hidden');
        document.getElementById('ar-instructions').textContent = 'üì± Tap the place button to position the model';
        
        try {
            // Check if THREE is available
            if (!window.THREE) {
                throw new Error("THREE.js not loaded");
            }
            
            // Setup Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                canvas: document.getElementById('ar-canvas') 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent background

            // Lighting
            scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(1, 2, 3);
            scene.add(light);

            // Add a simple cube to test rendering
            const testCube = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.2),
                new THREE.MeshStandardMaterial({ color: 0xff0000 })
            );
            testCube.position.set(0, 0, -2);
            scene.add(testCube);
            debugLog("Added test cube to scene");

            // Load model
            loadModel(modelData.model);

            // Initialize camera stream as background
            initCameraStream();

            // Check for device orientation support
            checkDeviceOrientation();

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Rotate test cube to verify rendering is working
                if (testCube) {
                    testCube.rotation.x += 0.01;
                    testCube.rotation.y += 0.01;
                }
                
                // Apply device orientation if available
                if (gyroAvailable && placed && model) {
                    // The model will be updated by the device orientation controls
                }
                
                renderer.render(scene, camera);
            }
            
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        } catch (error) {
            debugLog("Error in initFallbackAR: " + error.message);
            showError("Failed to initialize fallback AR", error.message);
        }
    }

    function loadModel(modelPath) {
        debugLog("Loading model: " + modelPath);
        updateProgress(10, "Loading 3D model...");
        
        // Create a simple cube as placeholder in case model fails to load
        const createFallbackCube = () => {
            debugLog("Creating fallback cube model");
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            cube.visible = false;
            cube.scale.set(0.5, 0.5, 0.5);
            scene.add(cube);
            return cube;
        };
        
        // Try to load the actual model
        try {
            // Check if GLTFLoader is available
            if (!window.GLTFLoader) {
                throw new Error("GLTFLoader not loaded");
            }
            
            const loader = new GLTFLoader();
            
            // Add timeout for model loading
            const modelLoadTimeout = setTimeout(() => {
                debugLog("Model load timeout reached");
                if (!modelLoaded) {
                    model = createFallbackCube();
                    modelLoaded = true;
                    updateProgress(100, "Using fallback model");
                    document.getElementById('loading').classList.add('hidden');
                    clearTimeout(initializationTimeout);
                }
            }, 10000); // 10 second timeout for model loading
            
            loader.load(
                modelPath,
                (gltf) => {
                    debugLog("Model loaded successfully");
                    clearTimeout(modelLoadTimeout);
                    model = gltf.scene;
                    model.visible = false;
                    model.scale.set(3.5, 3.5, 3.5);
                    scene.add(model);
                    modelLoaded = true;
                    
                    // If in fallback mode and camera is ready, hide loading screen
                    if (!usingFallbackMode || (usingFallbackMode && cameraInitialized)) {
                        document.getElementById('loading').classList.add('hidden');
                        clearTimeout(initializationTimeout);
                    }
                    
                    updateProgress(100, "Model loaded");
                },
                (xhr) => {
                    const percent = xhr.loaded / (xhr.total || 1) * 100;
                    updateProgress(percent, "Loading 3D model...");
                },
                (err) => {
                    debugLog("GLTF Load Error: " + err.message);
                    clearTimeout(modelLoadTimeout);
                    
                    // Create a fallback cube instead
                    model = createFallbackCube();
                    modelLoaded = true;
                    
                    // If in fallback mode and camera is ready, hide loading screen
                    if (!usingFallbackMode || (usingFallbackMode && cameraInitialized)) {
                        document.getElementById('loading').classList.add('hidden');
                        clearTimeout(initializationTimeout);
                    }
                    
                    updateProgress(100, "Using fallback model");
                }
            );
        } catch (e) {
            debugLog("Exception during model loading: " + e.message);
            model = createFallbackCube();
            modelLoaded = true;
            
            // If in fallback mode and camera is ready, hide loading screen
            if (!usingFallbackMode || (usingFallbackMode && cameraInitialized)) {
                document.getElementById('loading').classList.add('hidden');
                clearTimeout(initializationTimeout);
            }
            
            updateProgress(100, "Using fallback model");
        }
    }

    function initCameraStream() {
        debugLog("Initializing camera stream");
        videoElement = document.getElementById('video-background');
        videoElement.style.display = 'block';
        
        // Check if getUserMedia is supported
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: window.innerWidth },
                    height: { ideal: window.innerHeight }
                } 
            })
            .then(function(stream) {
                debugLog("Camera stream initialized successfully");
                videoElement.srcObject = stream;
                cameraInitialized = true;
                
                // If model is loaded, hide loading screen
                if (modelLoaded) {
                    document.getElementById('loading').classList.add('hidden');
                    clearTimeout(initializationTimeout);
                }
                
                updateProgress(100, "Camera initialized");
                
                // Add event listener to detect when video is actually playing
                videoElement.addEventListener('playing', () => {
                    debugLog("Camera video is now playing");
                });
            })
            .catch(function(error) {
                debugLog("Camera error: " + error.message);
                cameraInitialized = true; // Mark as initialized even though it failed
                
                // Create a black background instead
                videoElement.style.display = 'none';
                document.body.style.backgroundColor = '#000000';
                
                // If model is loaded, hide loading screen
                if (modelLoaded) {
                    document.getElementById('loading').classList.add('hidden');
                    clearTimeout(initializationTimeout);
                }
                
                // Don't show error, just continue without camera
                updateProgress(100, "Continuing without camera");
            });
        } else {
            debugLog("getUserMedia not supported");
            cameraInitialized = true; // Mark as initialized even though it failed
            
            // Create a black background instead
            videoElement.style.display = 'none';
            document.body.style.backgroundColor = '#000000';
            
            // If model is loaded, hide loading screen
            if (modelLoaded) {
                document.getElementById('loading').classList.add('hidden');
                clearTimeout(initializationTimeout);
            }
            
            // Don't show error, just continue without camera
            updateProgress(100, "Continuing without camera");
        }
    }

    function checkDeviceOrientation() {
        debugLog("Checking device orientation support");
        
        // Check if device orientation is available
        if (window.DeviceOrientationEvent) {
            // For iOS 13+ we need to request permission
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                debugLog("iOS device orientation permission required");
                // Create a button to request permission
                const permissionBtn = document.createElement('button');
                permissionBtn.innerHTML = "Enable Motion Controls";
                permissionBtn.className = "ar-button";
                permissionBtn.style.position = "absolute";
                permissionBtn.style.top = "50%";
                permissionBtn.style.left = "50%";
                permissionBtn.style.transform = "translate(-50%, -50%)";
                permissionBtn.style.zIndex = "1001";
                
                permissionBtn.onclick = () => {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                debugLog("Motion permission granted");
                                permissionBtn.remove();
                                initDeviceOrientation();
                            } else {
                                debugLog("Motion permission denied");
                                permissionBtn.remove();
                                // Continue without orientation
                            }
                        })
                        .catch(error => {
                            debugLog("Error requesting motion permission: " + error.message);
                            permissionBtn.remove();
                            // Continue without orientation
                        });
                };
                
                document.body.appendChild(permissionBtn);
            } else {
                // For non-iOS devices, just initialize
                initDeviceOrientation();
            }
        } else {
            debugLog("Device orientation not supported");
        }
    }

    function initDeviceOrientation() {
        debugLog("Initializing device orientation");
        
        // Simple orientation handler
        window.addEventListener('deviceorientation', function(event) {
            if (!gyroAvailable) {
                gyroAvailable = true;
                debugLog("Device orientation available");
            }
            
            if (model && placed) {
                // Use orientation data to adjust model or camera
                // This is a simplified approach - in a real app you'd use proper orientation controls
                const alpha = event.alpha || 0; // Z-axis rotation [0, 360)
                const beta = event.beta || 0;   // X-axis rotation [-180, 180]
                const gamma = event.gamma || 0; // Y-axis rotation [-90, 90]
                
                // Apply subtle movement based on device orientation
                // This creates an effect where the model appears to stay in place as you move the device
                model.rotation.x = THREE.MathUtils.degToRad(beta / 10);
                model.rotation.y = modelRotationY + THREE.MathUtils.degToRad(gamma / 10);
                model.rotation.z = THREE.MathUtils.degToRad(alpha / 10);
            }
        });
    }

    function updateProgress(percent, message = '') {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        if (progressFill) progressFill.style.width = percent + '%';
        if (progressText && message) progressText.textContent = message;
        
        if (DEBUG) {
            debugLog(`Progress: ${percent}% - ${message}`);
        }
    }

    function loadNewModel(modelName) {
        // Remove current model
        if (model) {
            scene.remove(model);
            model = null;
        }

        placed = false;
        modelLoaded = false;
        currentModelName = modelName;
        const modelData = MODEL_CONFIGS[modelName];

        document.getElementById('model-title').textContent = modelData.title;
        document.getElementById('model-subtitle').textContent = modelData.subtitle;

        // Show loading screen again
        document.getElementById('loading').classList.remove('hidden');
        updateProgress(0, "Loading new model...");

        loadModel(modelData.model);
    }

    // Check if modules are already loaded
    if (window.modulesLoaded) {
        initApp();
    } else {
        // Wait for modules to load
        window.addEventListener('threejsModulesLoaded', initApp);
        
        // Set a timeout in case modules don't load
        setTimeout(() => {
            if (!window.modulesLoaded) {
                showError("Failed to load required modules", "Please check your internet connection and try again.");
            }
        }, 10000);
    }

    // Initialize on DOM load as a fallback
    document.addEventListener('DOMContentLoaded', function() {
        // Only initialize if not already done
        if (!scene && !initializationTimeout) {
            debugLog("DOM loaded, checking if modules are loaded");
            if (window.modulesLoaded) {
                initApp();
            }
        }
    });
    </script>
</body>
</html>
