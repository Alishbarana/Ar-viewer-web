<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable AR Viewer</title>
    <!-- Three.js & WebXR -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/ARButton.js"></script>
    <style>
        /* ... (use your CSS from your prompt, unchanged) ... */
        /* For brevity, copy your CSS here */
    </style>
</head>
<body>
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing AR experience...</div>
        </div>
    </div>
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div>AR Not Supported</div>
        <div style="margin-top: 10px; font-size: 12px;">This device/browser does not support WebXR AR</div>
    </div>
    <!-- AR Overlay (UI) -->
    <div class="ar-overlay">
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Move around the model with directional controls</div>
        </div>
        <div class="ar-crosshair"></div>
        <div id="ar-instructions" class="ar-instructions">
            ðŸ“± Tap on a surface to place the model in AR!
        </div>
        <!-- ... (rest of your UI controls, unchanged) ... -->
    </div>
    <script>
    // --- Model configs (relative paths for GitHub Pages) ---
    const MODEL_CONFIGS = {
        array: {
            title: "Array Data Structure",
            subtitle: "Linear collection of elements with indexed access",
            model: "models/array.glb"
        },
        binary_tree: {
            title: "Binary Tree",
            subtitle: "Hierarchical structure with parent-child relationships",
            model: "models/binary_tree.glb"
        },
        linked_list: {
            title: "Linked List",
            subtitle: "Sequential nodes connected via pointers",
            model: "models/linked_list.glb"
        },
        stack: {
            title: "Stack (LIFO)",
            subtitle: "Last In First Out data structure",
            model: "models/stack.glb"
        },
        queue: {
            title: "Queue (FIFO)",
            subtitle: "First In First Out data structure",
            model: "models/queue.glb"
        },
        merge_sort: {
            title: "Merge Sort Algorithm",
            subtitle: "Divide and conquer sorting technique",
            model: "models/merge_sort.glb"
        },
        osi_model: {
            title: "OSI Model",
            subtitle: "7-layer network communication framework",
            model: "models/osi_model.glb"
        },
        client_server: {
            title: "Client-Server Architecture",
            subtitle: "Distributed computing model",
            model: "models/client_server.glb"
        },
        firewall: {
            title: "Network Firewall",
            subtitle: "Security barrier for network traffic",
            model: "models/firewall.glb"
        },
        router: {
            title: "Network Router",
            subtitle: "Data packet forwarding device",
            model: "models/router.glb"
        }
    };

    let scene, camera, renderer, controller, reticle, model, currentModelName;
    let placed = false;

    document.addEventListener('DOMContentLoaded', async function() {
        // Get model name from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentModelName = urlParams.get('model') || 'array';
        const modelData = MODEL_CONFIGS[currentModelName] || MODEL_CONFIGS.array;
        document.getElementById('model-title').textContent = modelData.title;
        document.getElementById('model-subtitle').textContent = modelData.subtitle;

        // Check WebXR support
        if (navigator.xr && navigator.xr.isSessionSupported) {
            navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                if (supported) {
                    initWebXR(modelData);
                } else {
                    showError("WebXR AR not supported on this device/browser.");
                }
            });
        } else {
            showError("WebXR AR not supported on this device/browser.");
        }
    });

    function showError(msg) {
        document.getElementById('loading').classList.add('hidden');
        const errorDiv = document.getElementById('error');
        if (errorDiv) {
            errorDiv.querySelector('div').textContent = msg;
            errorDiv.classList.remove('hidden');
        }
    }

    function initWebXR(modelData) {
        // Setup Three.js scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: document.getElementById('ar-canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        // Lighting
        scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(1, 2, 3);
        scene.add(light);

        // Reticle for placement
        reticle = new THREE.Mesh(
            new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // ARButton
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        // Controller for hit test
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        // Load model (but don't add to scene yet)
        const loader = new THREE.GLTFLoader();
        loader.load(
            modelData.model,
            (gltf) => {
                model = gltf.scene;
                model.visible = false;
                model.scale.set(3.5, 3.5, 3.5);
                scene.add(model);
                document.getElementById('loading').classList.add('hidden');
            },
            (xhr) => {
                // Progress
                const percent = xhr.loaded / (xhr.total || 1) * 100;
                updateProgress(percent, "Loading 3D model...");
            },
            (err) => {
                showError("Failed to load model.");
            }
        );

        // Animation loop
        renderer.setAnimationLoop(render);

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hit test source
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0 && !placed) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function onSelect() {
            if (reticle.visible && model && !placed) {
                model.position.setFromMatrixPosition(reticle.matrix);
                model.visible = true;
                placed = true;
                reticle.visible = false;
                document.getElementById('ar-instructions').classList.add('hidden');
            }
        }
    }

    function updateProgress(percent, message = '') {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        if (progressFill) progressFill.style.width = percent + '%';
        if (progressText && message) progressText.textContent = message;
    }
    </script>
</body>
</html>