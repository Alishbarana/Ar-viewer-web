<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable AR Viewer</title>
    <!-- Three.js & WebXR -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/ARButton.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        #ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            display: none; /* Hidden by default */
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        
        .progress-container {
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #00ffff;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            font-size: 14px;
        }
        
        .error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ar-header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .ar-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .ar-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .ar-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .ar-instructions {
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            font-size: 16px;
            pointer-events: none;
        }
        
        .ar-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: auto;
        }
        
        .ar-button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 0 10px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .ar-button:active {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        .fallback-notice {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .model-selector {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            z-index: 100;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            transition: transform 0.3s ease-out;
          }
          .toast-visible {
            transform: translateX(-50%) translateY(0);
          }
          .toast-error {
            background: rgba(220,53,69,0.9);
          }

        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border-width: 0;
        }
    </style>
</head>
<body>
    <!-- Video Background for Fallback Mode -->
    <video id="video-background" autoplay playsinline></video>
    
    <!-- 3D Canvas -->
    <canvas id="ar-canvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing AR experience...</div>
        </div>
    </div>
    
    <!-- Error Screen -->
    <div id="error" class="error hidden">
        <div>AR Not Supported</div>
        <div style="margin-top: 10px; font-size: 12px;">This device/browser does not support WebXR AR</div>
    </div>
    
    <!-- AR Overlay (UI) -->
    <div class="ar-overlay">
        <div id="fallback-notice" class="fallback-notice hidden">Using camera fallback mode</div>
        <div class="ar-header">
            <div class="ar-title" id="model-title">Loading...</div>
            <div class="ar-subtitle" id="model-subtitle">Move around the model with directional controls</div>
        </div>
        <div class="ar-crosshair"></div>
        <div id="ar-instructions" class="ar-instructions">
            üì± Tap on a surface to place the model in AR!
        </div>
        <div class="ar-controls">
            <button class="ar-button" id="rotate-left">‚ü≤</button>
            <button class="ar-button" id="place-model">üìç</button>
            <button class="ar-button" id="rotate-right">‚ü≥</button>
            <button class="ar-button" id="scale-down">-</button>
            <button class="ar-button" id="scale-up">+</button>
        </div>
    </div>

    <div class="model-selector">
        <button id="prev-model">‚óÄ</button>
        <button id="next-model">‚ñ∂</button>
    </div>
    
    <script>
    // Create namespaced modules
const ARApp = {
  config: {}, // Store configuration
  webXR: {},  // WebXR specific functionality
  fallback: {}, // Fallback mode functionality
  ui: {},     // UI controls and interactions
  utils: {},  // Utility functions
  init() {    // Main initialization
    this.setupEventListeners();
    this.loadModelConfig();
    this.checkARSupport();
  }
};

ARApp.config.models = {
        array: {
            title: "Array Data Structure",
            subtitle: "Linear collection of elements with indexed access",
            model: "models/array.glb"
        },
        binary_tree: {
            title: "Binary Tree",
            subtitle: "Hierarchical structure with parent-child relationships",
            model: "models/binary_tree.glb"
        },
        linked_list: {
            title: "Linked List",
            subtitle: "Sequential nodes connected via pointers",
            model: "models/linked_list.glb"
        },
        stack: {
            title: "Stack (LIFO)",
            subtitle: "Last In First Out data structure",
            model: "models/stack.glb"
        },
        queue: {
            title: "Queue (FIFO)",
            subtitle: "First In First Out data structure",
            model: "models/queue.glb"
        },
        merge_sort: {
            title: "Merge Sort Algorithm",
            subtitle: "Divide and conquer sorting technique",
            model: "models/merge_sort.glb"
        },
        osi_model: {
            title: "OSI Model",
            subtitle: "7-layer network communication framework",
            model: "models/osi_model.glb"
        },
        client_server: {
            title: "Client-Server Architecture",
            subtitle: "Distributed computing model",
            model: "models/client_server.glb"
        },
        firewall: {
            title: "Network Firewall",
            subtitle: "Security barrier for network traffic",
            model: "models/firewall.glb"
        },
        router: {
            title: "Network Router",
            subtitle: "Data packet forwarding device",
            model: "models/router.glb"
        }
    };

    let scene, camera, renderer, controller, reticle, model, currentModelName;
    let placed = false;
    let usingFallbackMode = false;
    let gyroAvailable = false;
    let deviceOrientationControls = null;
    let modelRotationY = 0;
    let videoElement;

    let lastFrameTime = 0;
    let frameRate = 60;

    document.addEventListener('DOMContentLoaded', () => ARApp.init());

    ARApp.setupEventListeners = function() {
        document.getElementById('place-model').addEventListener('click', () => {
            if (usingFallbackMode && !placed && model) {
                placed = true;
                model.visible = true;
                // Position the model in front of the camera
                model.position.set(0, 0, -2);
                document.getElementById('ar-instructions').classList.add('hidden');
            }
        });

        document.getElementById('rotate-left').addEventListener('click', () => {
            if (model && placed) {
                modelRotationY -= Math.PI / 8;
                model.rotation.y = modelRotationY;
            }
        });

        document.getElementById('rotate-right').addEventListener('click', () => {
            if (model && placed) {
                modelRotationY += Math.PI / 8;
                model.rotation.y = modelRotationY;
            }
        });

        document.getElementById('scale-up').addEventListener('click', () => {
            if (model && placed) {
                const currentScale = model.scale.x;
                model.scale.set(currentScale * 1.2, currentScale * 1.2, currentScale * 1.2);
            }
        });

        document.getElementById('scale-down').addEventListener('click', () => {
            if (model && placed) {
                const currentScale = model.scale.x;
                model.scale.set(currentScale * 0.8, currentScale * 0.8, currentScale * 0.8);
            }
        });

        // Update your buttons with proper ARIA roles
        document.querySelectorAll('.ar-button').forEach(button => {
          button.setAttribute('role', 'button');
          button.setAttribute('tabindex', '0');
          button.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              button.click();
            }
          });
        });
    }

    ARApp.loadModelConfig = function() {
        // Get model name from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentModelName = urlParams.get('model') || 'array';
        const modelData = ARApp.config.models[currentModelName] || ARApp.config.models.array;
        document.getElementById('model-title').textContent = modelData.title;
        document.getElementById('model-subtitle').textContent = modelData.subtitle;
    }

    // Add this utility function
    function logError(component, error, fatal = false) {
        console.error(`[${component}] ${error.message || error}`);

        // For non-fatal errors, show a toast notification
        if (!fatal) {
            showToast(`Error: ${error.message || error}`, 'error');
        } else {
            showError(`${error.message || error}`);
        }

        // Optional: send to analytics/logging service
    }

    // Add a toast notification system
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('toast-visible');
            setTimeout(() => {
                toast.classList.remove('toast-visible');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }, 10);
    }

    // Add this function to check device capabilities
    function checkDeviceCapabilities() {
        const capabilities = {
            webGL: false,
            webXR: false,
            camera: false,
            gyroscope: false,
            touchscreen: false
        };

        // Check WebGL
        try {
            const canvas = document.createElement('canvas');
            capabilities.webGL = !!(window.WebGLRenderingContext &&
                (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {
            capabilities.webGL = false;
        }

        // Check WebXR
        capabilities.webXR = !!(navigator.xr && typeof navigator.xr.isSessionSupported === 'function');

        // Check camera
        capabilities.camera = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);

        // Check gyroscope
        capabilities.gyroscope = !!(window.DeviceOrientationEvent);

        // Check touchscreen
        capabilities.touchscreen = 'ontouchstart' in window;

        console.log('Device capabilities:', capabilities);
        return capabilities;
    }

    // Call this during initialization
    const deviceCapabilities = checkDeviceCapabilities();

    ARApp.checkARSupport = function() {
        // Check WebXR support with robust error handling
        try {
            if (navigator.xr && typeof navigator.xr.isSessionSupported === 'function') {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        initWebXR(ARApp.config.models[currentModelName] || ARApp.config.models.array);
                    } else {
                        console.log("WebXR AR not supported, trying fallback mode");
                        initFallbackAR(ARApp.config.models[currentModelName] || ARApp.config.models.array);
                    }
                }).catch((err) => {
                    console.error("Error checking WebXR support:", err);
                    initFallbackAR(ARApp.config.models[currentModelName] || ARApp.config.models.array);
                });
            } else {
                console.log("WebXR not available, trying fallback mode");
                initFallbackAR(ARApp.config.models[currentModelName] || ARApp.config.models.array);
            }
        } catch (e) {
            console.error("Exception during AR support check:", e);
            initFallbackAR(ARApp.config.models[currentModelName] || ARApp.config.models.array);
        }
    }

    function showError(msg) {
        // Hide loading screen
        document.getElementById('loading').classList.add('hidden');
        // Show error message
        const errorDiv = document.getElementById('error');
        if (errorDiv) {
            errorDiv.querySelector('div').textContent = msg;
            errorDiv.classList.remove('hidden');
        } else {
            // Fallback: alert if error div is missing
            alert(msg);
        }
    }

    function initWebXR(modelData) {
        // Setup Three.js scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, canvas: document.getElementById('ar-canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        // Lighting
        scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(1, 2, 3);
        scene.add(light);

        // Reticle for placement
        reticle = new THREE.Mesh(
            new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // ARButton
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        // Controller for hit test
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        // Load model (but don't add to scene yet)
        loadModel(modelData.model);

        // Animation loop
        renderer.setAnimationLoop(render);

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hit test source
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        // Add environment light estimation for realistic rendering:
        if (navigator.xr && typeof navigator.xr.requestSession === 'function') {
          const sessionInit = { 
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['light-estimation'] 
          };
          
          navigator.xr.requestSession('immersive-ar', sessionInit).then(session => {
            if ('requestLightProbe' in session) {
              session.requestLightProbe().then(lightProbe => {
                lightProbe.addEventListener('reflectionchange', () => {
                  const estimate = lightProbe.reflectionchange;
                  // Update lighting in your scene based on the estimate
                  updateSceneLighting(estimate);
                });
              }).catch(err => {
                console.log('Light estimation not available:', err);
              });
            }
          });
        }

        // Add object occlusion for more realistic AR:
        const sessionInit = { 
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['light-estimation', 'depth-sensing'] 
        };

        function updateSceneLighting(estimate) {
          // Create environment map from light probe
          if (estimate && estimate.sphericalHarmonicsCoefficients) {
            const sh = estimate.sphericalHarmonicsCoefficients;
            const envMap = new THREE.LightProbe();
            envMap.sh.fromArray(sh);
            envMap.intensity = 1;
            scene.environment = envMap;
          }
        }

        // Add depth handling
        function setupDepthSensing(session) {
          if ('getDepthInformation' in frame) {
            const depthInfo = frame.getDepthInformation(view);
            if (depthInfo) {
              // Create depth texture
              const depthTexture = new THREE.DataTexture(
                depthInfo.data,
                depthInfo.width,
                depthInfo.height,
                THREE.RedFormat,
                THREE.FloatType
              );
              
              // Use depth texture for occlusion
              const occlusionMaterial = new THREE.MeshBasicMaterial({
                map: depthTexture,
                transparent: true
              });
              
              // Create occlusion plane
              const occlusionPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                occlusionMaterial
              );
              occlusionPlane.renderOrder = -1;
              scene.add(occlusionPlane);
            }
          }
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0 && !placed) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            updateFrameRate(timestamp);
            renderer.render(scene, camera);
        }

        function onSelect() {
            if (reticle.visible && model && !placed) {
                model.position.setFromMatrixPosition(reticle.matrix);
                model.visible = true;
                placed = true;
                reticle.visible = false;
                document.getElementById('ar-instructions').classList.add('hidden');
            }
        }
    }

    let isDragging = false;
    let previousTouch = { x: 0, y: 0 };

    document.getElementById('ar-canvas').addEventListener('touchstart', (event) => {
        if (usingFallbackMode && placed && event.touches.length === 1) {
            isDragging = true;
            previousTouch.x = event.touches[0].clientX;
            previousTouch.y = event.touches[0].clientY;
        }
    });

    document.getElementById('ar-canvas').addEventListener('touchmove', (event) => {
        if (isDragging && model) {
            const touch = event.touches[0];
            const movementX = (touch.clientX - previousTouch.x) * 0.01;
            const movementY = (touch.clientY - previousTouch.y) * 0.01;

            model.position.x += movementX;
            model.position.y -= movementY;

            previousTouch.x = touch.clientX;
            previousTouch.y = touch.clientY;
        }
    });

    document.getElementById('ar-canvas').addEventListener('touchend', () => {
        isDragging = false;
    });

    // Add gesture recognition for model manipulation:
    let initialTouchDistance = 0;
    let initialModelScale = 1;

    document.getElementById('ar-canvas').addEventListener('touchstart', (event) => {
      if (event.touches.length === 2) {
        // Pinch gesture start
        initialTouchDistance = Math.hypot(
          event.touches[0].clientX - event.touches[1].clientX,
          event.touches[0].clientY - event.touches[1].clientY
        );
        initialModelScale = model.scale.x;
      }
    });

    document.getElementById('ar-canvas').addEventListener('touchmove', (event) => {
      if (event.touches.length === 2 && model && placed) {
        // Pinch gesture move - handle scaling
        const currentDistance = Math.hypot(
          event.touches[0].clientX - event.touches[1].clientX,
          event.touches[0].clientY - event.touches[1].clientY
        );
        
        const scaleFactor = currentDistance / initialTouchDistance;
        const newScale = initialModelScale * scaleFactor;
        
        // Limit scale range
        const clampedScale = Math.min(Math.max(newScale, 0.5), 5.0);
        model.scale.set(clampedScale, clampedScale, clampedScale);
      }
    });

    function initFallbackAR(modelData) {
        usingFallbackMode = true;
        document.getElementById('fallback-notice').classList.remove('hidden');
        document.getElementById('ar-instructions').textContent = 'üì± Tap the place button to position the model';
        
        // Setup Three.js scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true, 
            canvas: document.getElementById('ar-canvas') 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Transparent background

        // Lighting
        scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(1, 2, 3);
        scene.add(light);

        // Load model
        loadModel(modelData.model);

        // Initialize camera stream as background
        initCameraStream();

        // Check for device orientation support
        checkDeviceOrientation();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Apply device orientation if available
            if (gyroAvailable && placed) {
                // The model will be updated by the device orientation controls
            }
            
            updateFrameRate(performance.now());
            renderer.render(scene, camera);
        }
        
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function loadModel(modelPath) {
        // Add KTX2 and Draco compression support
        const ktx2Loader = new THREE.KTX2Loader();
        ktx2Loader.setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/basis/');
        ktx2Loader.detectSupport(renderer);
        
        const dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
        
        const loader = new THREE.GLTFLoader();
        loader.setKTX2Loader(ktx2Loader);
        loader.setDRACOLoader(dracoLoader);
        
        loader.load(
            modelPath,
            (gltf) => {
                //model = gltf.scene;
                //model.visible = false;
                //model.scale.set(3.5, 3.5, 3.5);
                //scene.add(model);
                model = createModelWithLOD(gltf);
                model.visible = false;
                scene.add(model);
                document.getElementById('loading').classList.add('hidden');
            },
            (xhr) => {
                const percent = xhr.loaded / (xhr.total || 1) * 100;
                updateProgress(percent, "Loading 3D model...");
            },
            (err) => {
                console.error("GLTF Load Error:", err);
                showError("Failed to load model.");
            }
        );
    }

    function createModelWithLOD(gltf) {
        const lod = new THREE.LOD();
        
        // Original high-quality model
        const highDetail = gltf.scene;
        highDetail.scale.set(3.5, 3.5, 3.5);
        lod.addLevel(highDetail, 0);
        
        // Create simplified version for distance viewing
        const lowDetail = highDetail.clone();
        // Apply simplification or swap with a lower poly version
        lowDetail.traverse(obj => {
            if (obj.isMesh && obj.geometry) {
              // Simplify geometry or use lower resolution textures
            }
        });
        lod.addLevel(lowDetail, 5);
        
        return lod;
    }

    function initCameraStream() {
        videoElement = document.getElementById('video-background');
        videoElement.style.display = 'block';
        
        // Check if getUserMedia is supported
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: window.innerWidth },
                    height: { ideal: window.innerHeight }
                } 
            })
            .then(function(stream) {
                videoElement.srcObject = stream;
                updateProgress(100, "Camera initialized");
            })
            .catch(function(error) {
                console.error("Camera error:", error);
                showError("Could not access camera. Please ensure camera permissions are granted.");
            });
        } else {
            showError("Your browser doesn't support camera access.");
        }
    }

    function checkDeviceOrientation() {
        // Check if device orientation is available
        if (window.DeviceOrientationEvent) {
            // For iOS 13+ we need to request permission
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // Create a button to request permission
                const permissionBtn = document.createElement('button');
                permissionBtn.innerHTML = "Enable Motion Controls";
                permissionBtn.className = "ar-button";
                permissionBtn.style.position = "absolute";
                permissionBtn.style.top = "50%";
                permissionBtn.style.left = "50%";
                permissionBtn.style.transform = "translate(-50%, -50%)";
                permissionBtn.style.zIndex = "1001";
                
                permissionBtn.onclick = () => {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                permissionBtn.remove();
                                initDeviceOrientation();
                            } else {
                                showError("Motion permission denied");
                            }
                        })
                        .catch(console.error);
                };
                
                document.body.appendChild(permissionBtn);
            } else {
                // For non-iOS devices, just initialize
                initDeviceOrientation();
            }
        } else {
            console.log("Device orientation not supported");
        }
    }

    function initDeviceOrientation() {
        // Simple orientation handler
        window.addEventListener('deviceorientation', function(event) {
            if (!gyroAvailable) {
                gyroAvailable = true;
                console.log("Device orientation available");
            }
            
            if (model && placed) {
                // Use orientation data to adjust model or camera
                // This is a simplified approach - in a real app you'd use proper orientation controls
                const alpha = event.alpha || 0; // Z-axis rotation [0, 360)
                const beta = event.beta || 0;   // X-axis rotation [-180, 180]
                const gamma = event.gamma || 0; // Y-axis rotation [-90, 90]
                
                // Apply subtle movement based on device orientation
                // This creates an effect where the model appears to stay in place as you move the device
                model.rotation.x = THREE.MathUtils.degToRad(beta / 10);
                model.rotation.y = modelRotationY + THREE.MathUtils.degToRad(gamma / 10);
                model.rotation.z = THREE.MathUtils.degToRad(alpha / 10);
            }
        });
    }

    function updateProgress(percent, message = '') {
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        if (progressFill) progressFill.style.width = percent + '%';
        if (progressText && message) progressText.textContent = message;
    }

    function updateFrameRate(timestamp) {
        if (lastFrameTime === 0) {
          lastFrameTime = timestamp;
          return;
        }
        
        const delta = timestamp - lastFrameTime;
        frameRate = 1000 / delta;
        lastFrameTime = timestamp;
        
        // Adapt quality based on frame rate
        if (frameRate < 30) {
          // Reduce quality
          renderer.setPixelRatio(window.devicePixelRatio * 0.7);
        } else {
          // Restore quality
          renderer.setPixelRatio(window.devicePixelRatio);
        }
      }

    const MODEL_CONFIGS = ARApp.config.models;
    const modelKeys = Object.keys(MODEL_CONFIGS);
    let currentModelIndex = modelKeys.indexOf(currentModelName);

    document.getElementById('prev-model').addEventListener('click', () => {
        currentModelIndex = (currentModelIndex - 1 + modelKeys.length) % modelKeys.length;
        loadNewModel(modelKeys[currentModelIndex]);
    });

    document.getElementById('next-model').addEventListener('click', () => {
        currentModelIndex = (currentModelIndex + 1) % modelKeys.length;
        loadNewModel(modelKeys[currentModelIndex]);
    });

    function loadNewModel(modelName) {
        // Remove current model
        if (model) {
            scene.remove(model);
            model = null;
        }

        placed = false;
        currentModelName = modelName;
        const modelData = MODEL_CONFIGS[modelName];

        document.getElementById('model-title').textContent = modelData.title;
        document.getElementById('model-subtitle').textContent = modelData.subtitle;

        loadModel(modelData.model);
    }

    // Add screen reader announcements
    function announceToScreenReader(message) {
      const announcement = document.createElement('div');
      announcement.setAttribute('aria-live', 'polite');
      announcement.classList.add('sr-only');
      announcement.textContent = message;
      document.body.appendChild(announcement);
      
      setTimeout(() => {
        announcement.textContent = '';
        setTimeout(() => announcement.remove(), 100);
      }, 3000);
    }

    // Add CSS for toasts
    const style = document.createElement('style');
    style.textContent = `
      .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        transition: transform 0.3s ease-out;
      }
      .toast-visible {
        transform: translateX(-50%) translateY(0);
      }
      .toast-error {
        background: rgba(220,53,69,0.9);
      }
    `;
    document.head.appendChild(style);

    // Add this to your script
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/ar-service-worker.js')
          .then(registration => {
            console.log('ServiceWorker registration successful');
          })
          .catch(error => {
            console.error('ServiceWorker registration failed:', error);
          });
      });
    }

// Add this to your initialization
const analytics = {
  sessionStart: Date.now(),
  events: [],
  deviceInfo: {
    userAgent: navigator.userAgent,
    screenSize: `${window.innerWidth}x${window.innerHeight}`,
    pixelRatio: window.devicePixelRatio,
    language: navigator.language
  },
  
  logEvent(category, action, label = null, value = null) {
    this.events.push({
      timestamp: Date.now(),
      category,
      action,
      label,
      value
    });
    
    // If you have a backend analytics service:
    // sendToAnalyticsServer({ category, action, label, value });
    
    console.log(`Analytics: ${category} - ${action} - ${label} - ${value}`);
  },
  
  getSessionDuration() {
    return Math.floor((Date.now() - this.sessionStart) / 1000);
  }
};

// Track key events
function trackAREvents() {
  analytics.logEvent('ar_session', 'start', usingFallbackMode ? 'fallback' : 'webxr');
  
  // Track model placement
  document.getElementById('place-model').addEventListener('click', () => {
    if (usingFallbackMode && !placed && model) {
      analytics.logEvent('model', 'placed', currentModelName);
    }
  });
  
  // Track session duration when page is closed
  window.addEventListener('beforeunload', () => {
    analytics.logEvent('ar_session', 'end', null, analytics.getSessionDuration());
  });
}

// Call this during initialization
trackAREvents();

// Add battery monitoring
if ('getBattery' in navigator) {
  navigator.getBattery().then(battery => {
    // Initial battery check
    checkBatteryStatus(battery);
    
    // Monitor for changes
    battery.addEventListener('levelchange', () => {
      checkBatteryStatus(battery);
    });
  });
}

function checkBatteryStatus(battery) {
  const batteryLevel = battery.level * 100; // Convert to percentage
  
  // Low battery mode
  if (batteryLevel < 15) {
    // Reduce quality to save battery
    renderer.setPixelRatio(1.0);
    renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);
    
    // Reduce animation frame rate
    if (!battery.charging) {
      // Use a throttled animation loop
      useThrottledAnimationLoop(30); // 30fps instead of 60fps
    }
    
    showToast("Low battery mode activated", "info");
  }
}

// Throttled animation loop
let targetFPS = 60;

function useThrottledAnimationLoop(fps) {
  targetFPS = fps;
}

function throttledAnimationFrame(timestamp) {
  requestAnimationFrame(throttledAnimationFrame);
  
  const elapsed = timestamp - lastFrameTime;
  const fpsInterval = 1000 / targetFPS;
  
  if (elapsed < fpsInterval) return;
  
  lastFrameTime = timestamp - (elapsed % fpsInterval);
  
  // Your render code here
  renderer.render(scene, camera);
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden, pause intensive operations
    if (usingFallbackMode) {
      // Pause video if in fallback mode
      if (videoElement && !videoElement.paused) {
        videoElement.pause();
      }
    }
    
    analytics.logEvent('visibility', 'hidden');
  } else {
    // Page is visible again, resume operations
    if (usingFallbackMode) {
      // Resume video if in fallback mode
      if (videoElement && videoElement.paused) {
        videoElement.play();
      }
    }
    
    analytics.logEvent('visibility', 'visible');
  }
});
    </script>
</body>
</html>
